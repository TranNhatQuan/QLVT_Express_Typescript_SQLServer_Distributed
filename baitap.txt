4.1:
SELECT ENO, PNAME
FROM PROJ2 NATURAL JOIN ASG
WHERE PNO = "P4"
4.2
SELECT RESP, BUDGET
FROM PROJ1 NATURAL JOIN ASG1
WHERE PNAME = "CAD/CAM"

UNION

SELECT RESP, BUDGET
FROM PROJ2 NATURAL JOIN ASG2
WHERE PNAME = "CAD/CAM"

UNION

SELECT RESP, BUDGET
FROM PROJ2 NATURAL JOIN ASG3
WHERE PNAME = "CAD/CAM"

Truy vấn trên phân mảnh này tốt hơn truy vấn gốc vì nó giảm số lượng dữ liệu cần xử lý
4.3
SELECT ENAME
FROM EMP1 NATURAL JOIN ASG1 NATURAL JOIN PROJ1
WHERE PNAME = "Instrumentation"

UNION

SELECT ENAME
FROM EMP1 NATURAL JOIN ASG2 NATURAL JOIN PROJ2
WHERE PNAME = "Instrumentation"

4.4
Join program tối ưu:

    Truyền EMP (100 hàng) và ASG (200 hàng) đến site của PROJ.
Thực hiện JOIN (EMP ⋈ ASG) ⋈ PROJ tại site của PROJ.
4.5
Truyền EMP (100 hàng) và ASG (200 hàng) đến site của PROJ song song.
Thực hiện JOIN (EMP ⋈ ASG) ⋈ PROJ tại site của PROJ.
4.6
Ta sẽ thực hiện các phép semijoin theo thứ tự sau để giảm kích thước từng quan hệ:
Bước 1: Giảm ASG bằng semijoin với EMP

    Semijoin: ASG ⋉ EMP.
        Truyền các giá trị ENO từ EMP (ở S1) đến site của ASG (S2).
        Kích thước truyền: 100 hàng (giả định mỗi hàng có một giá trị ENO duy nhất, không lặp lại).
        Tại S2, lọc ASG để chỉ giữ các hàng có ENO tồn tại trong EMP.
        Kết quả: ASG' (phần giảm của ASG) có kích thước tối đa 200 (vì ASG gốc có 200 hàng), nhưng chỉ chứa các hàng khớp với EMP. Vì size(EMP ⋈ ASG) = 300, ta giả định tất cả hàng của ASG đều khớp với một số hàng của EMP, nên ASG' vẫn có 200 hàng (không giảm ngay).

Bước 2: Giảm ASG' bằng semijoin với PROJ

    Semijoin: ASG' ⋉ PROJ.
        Truyền các giá trị PNO từ PROJ (ở S3) đến site của ASG (S2).
        Kích thước truyền: 300 hàng (giả định mỗi hàng có một giá trị PNO duy nhất).
        Tại S2, lọc ASG' để chỉ giữ các hàng có PNO tồn tại trong PROJ.
        Kết quả: ASG'' (phần giảm thêm của ASG) có kích thước bằng size(ASG ⋈ PROJ) = 200, vì chỉ những hàng của ASG khớp với PROJ được giữ lại.

Bước 3: Giảm EMP bằng semijoin với ASG''

    Semijoin: EMP ⋉ ASG''.
        Truyền các giá trị ENO từ ASG'' (ở S2) đến site của EMP (S1).
        Kích thước truyền: 200 hàng (giả định mỗi hàng có một giá trị ENO duy nhất).
        Tại S1, lọc EMP để chỉ giữ các hàng có ENO tồn tại trong ASG''.
        Kết quả: EMP' có kích thước tối đa bằng size(EMP ⋈ ASG) = 300, nhưng vì EMP gốc có 100 hàng và tất cả có thể khớp, ta giữ 100 hàng (giả định không giảm thêm vì tất cả hàng của EMP đều liên quan).

Bước 4: Giảm PROJ bằng semijoin với ASG''

    Semijoin: PROJ ⋉ ASG''.
        Truyền các giá trị PNO từ ASG'' (ở S2) đến site của PROJ (S3).
        Kích thước truyền: 200 hàng (giả định mỗi hàng có một giá trị PNO duy nhất).
        Tại S3, lọc PROJ để chỉ giữ các hàng có PNO tồn tại trong ASG''.
        Kết quả: PROJ' có kích thước bằng size(ASG ⋈ PROJ) = 200, vì chỉ những hàng của PROJ khớp với ASG'' được giữ lại.
4.7
Trường hợp 1: Mạng chung (General Network)

    Đặc điểm: Dữ liệu chỉ truyền đến site cần thiết.

Bước 1: Giảm kích thước bằng semijoin

    Giảm ASG (S2) với EMP:
        Truyền ENO từ EMP (S1: 1000, S2: 1000, S3: 1000) đến ASG (S2).
        Tổng số hàng truyền: 1000 + 1000 + 1000 = 3000.
        Tại S2, lọc ASG (2000 hàng) để giữ các hàng có ENO khớp với EMP từ S1, S2, S3.
        Kết quả: ASG' tại S2, kích thước tối đa 2000, nhưng chỉ chứa hàng khớp, giả định giảm còn 2000 (vì size(EMP ⋈ ASG) = 2000).
    Giảm ASG' (S2) với PROJ (S1):
        Truyền PNO từ PROJ (S1: 1000) đến ASG' (S2).
        Tổng số hàng truyền: 1000.
        Tại S2, lọc ASG' để giữ các hàng có PNO khớp với PROJ.
        Kết quả: ASG'' tại S2, kích thước bằng size(ASG ⋈ PROJ) = 1000.
    Giảm EMP với ASG'' (S2):
        Truyền ENO từ ASG'' (S2: 1000) đến EMP (S1, S2, S3).
        Tổng số hàng truyền: 1000.
        Tại S1, S2, S3, lọc EMP (1000 mỗi site) để giữ các hàng có ENO khớp với ASG''.
        Kết quả: EMP' tại S1, S2, S3, tổng kích thước 2000 (phân bố đều, ~667 mỗi site).
    Giảm PROJ (S1) với ASG'' (S2):
        Truyền PNO từ ASG'' (S2: 1000) đến PROJ (S1).
        Tổng số hàng truyền: 1000.
        Tại S1, lọc PROJ (1000 hàng) để giữ các hàng có PNO khớp với ASG''.
        Kết quả: PROJ' tại S1, kích thước 1000 (không giảm, vì tất cả khớp).
    Tổng chi phí truyền semijoin: 3000 + 1000 + 1000 + 1000 = 5000.

Bước 2: Thực hiện nối

    Sau khi giảm:
        EMP': S1 (~667), S2 (~667), S3 (~666), tổng 2000.
        ASG'': S2 (1000).
        PROJ': S1 (1000).
    Chọn site S2 (có ASG'') để thực hiện nối:
        Truyền EMP' từ S1 (667), S2 (667), S3 (666) đến S2: 2000 hàng.
        Truyền PROJ' từ S1 (1000) đến S2: 1000 hàng.
        Tổng chi phí truyền nối: 2000 + 1000 = 3000.
    Tổng chi phí truyền: 5000 + 3000 = 8000.

Trường hợp 2: Mạng phát sóng (Broadcast Network)

    Đặc điểm: Dữ liệu được phát sóng đến tất cả site, nhưng chỉ site cần thiết xử lý.

Bước 1: Giảm kích thước bằng semijoin

    Giảm ASG (S2) với EMP:
        Phát sóng ENO từ EMP (S1: 1000, S2: 1000, S3: 1000) đến tất cả site.
        Tổng số hàng phát sóng: 3000.
        Tại S2, lọc ASG (2000 hàng) thành ASG' (2000 hàng, vì khớp với EMP).
    Giảm ASG' (S2) với PROJ (S1):
        Phát sóng PNO từ PROJ (S1: 1000) đến tất cả site.
        Tổng số hàng phát sóng: 1000.
        Tại S2, lọc ASG' thành ASG'' (1000 hàng).
    Giảm EMP với ASG'' (S2):
        Phát sóng ENO từ ASG'' (1000) đến tất cả site.
        Tổng số hàng phát sóng: 1000.
        Tại S1, S2, S3, lọc EMP thành EMP' (tổng 2000 hàng, ~667 mỗi site).
    Giảm PROJ (S1) với ASG'' (S2):
        Phát sóng PNO từ ASG'' (1000) đến tất cả site.
        Tổng số hàng phát sóng: 1000.
        Tại S1, lọc PROJ thành PROJ' (1000 hàng, không giảm).
    Tổng chi phí truyền semijoin: 3000 + 1000 + 1000 + 1000 = 5000.

Bước 2: Thực hiện nối

    Sau khi giảm:
        EMP': S1 (~667), S2 (~667), S3 (~666).
        ASG'': S2 (1000).
        PROJ': S1 (1000).
    Chọn S2 để nối:
        Truyền EMP' từ S1 (667), S2 (667), S3 (666) đến S2: 2000 hàng.
        Truyền PROJ' từ S1 (1000) đến S2: 1000 hàng.
        Tổng chi phí truyền nối: 3000.
    Tổng chi phí truyền: 5000 + 3000 = 8000.
4.8
Bước 1: Xác định kích thước sau khi áp dụng điều kiện

    Áp dụng điều kiện trên PROJ:
        PROJ (S3: 1000 hàng).
        Với selectivity factor 0.5:
            size(PROJ') = 1000 × 0.5 = 500 hàng (vẫn ở S3).

Bước 2: Giảm kích thước bằng semijoin

    Giảm ASG (S2) với PROJ' (S3):
        Truyền PNO từ PROJ' (S3: 500) đến ASG (S2: 3000).
        Chi phí truyền: 500.
        Lọc ASG để giữ các hàng có PNO khớp với PROJ'.
        Kích thước ASG' = size(ASG ⋈ PROJ'). Vì size(ASG ⋈ PROJ) = 1000 (khi PROJ là 1000), với PROJ' (500), giả định giảm tỷ lệ: size(ASG') = 1000 × (500/1000) = 500 hàng.
    Giảm EMP (S1) với ASG' (S2):
        Truyền ENO từ ASG' (S2: 500) đến EMP (S1: 2000).
        Chi phí truyền: 500.
        Lọc EMP để giữ các hàng có ENO khớp với ASG'.
        Kích thước EMP' = size(EMP ⋈ ASG'). Vì size(EMP ⋈ ASG) = 2000 (khi ASG là 3000 trong Problem 4.7), với ASG' (500), giả định size(EMP') = 2000 × (500/3000) = 333 hàng.
    Giảm PAY (S3) với EMP' (S1):
        Truyền ENO từ EMP' (S1: 333) đến PAY (S3: 500).
        Chi phí truyền: 333.
        Lọc PAY để giữ các hàng có ENO khớp với EMP'.
        Kích thước PAY' = size(PAY ⋈ EMP'). Theo giả định size(R ⋈ S) = max(size(R), size(S)), size(PAY') = max(500, 333) = 500 hàng.
    Tổng chi phí truyền semijoin: 500 + 500 + 333 = 1333.

Bước 3: Thực hiện nối

    Quan hệ sau khi giảm:
        PAY': S3 (500).
        EMP': S1 (333).
        ASG': S2 (500).
        PROJ': S3 (500).
    Chọn site S2 để thực hiện nối (vì ASG' chỉ có ở S2):
        Truyền PAY' từ S3 (500) đến S2: 500 hàng.
        Truyền EMP' từ S1 (333) đến S2: 333 hàng.
        Truyền PROJ' từ S3 (500) đến S2: 500 hàng.
        Tổng chi phí truyền nối: 500 + 333 + 500 = 1333.
    Tổng chi phí truyền: 1333 (semijoin) + 1333 (nối) = 2666.

Bước 4: Tính tổng thời gian

    Chi phí truyền: 2666.
    Chi phí xử lý:
        Xử lý điều kiện trên PROJ: 1000 hàng.
        Semijoin tại các site: Tổng dữ liệu xử lý ~ 3000 (ước lượng từ ASG, EMP, PAY).
        Nối tại S2: Tổng dữ liệu xử lý ~ 500 (ước lượng từ ASG').
        Tổng dữ liệu xử lý: 1000 + 3000 + 500 = 4500.
        Truyền chậm hơn xử lý 100 lần, nên chi phí xử lý tương đương truyền: 4500 / 100 = 45.
    Tổng thời gian: 2666 + 45 = 2711.

Chương trình phân tán

    Giảm PROJ tại S3:
        Áp dụng điều kiện, PROJ' (S3: 500).
    Semijoin:
        ASG ⋉ PROJ': Truyền PNO từ S3 (500) đến S2, lọc ASG' (500).
        EMP ⋉ ASG': Truyền ENO từ S2 (500) đến S1, lọc EMP' (333).
        PAY ⋉ EMP': Truyền ENO từ S1 (333) đến S3, lọc PAY' (500).
    Thực hiện nối tại S2:
        Truyền PAY' từ S3 (500) đến S2.
        Truyền EMP' từ S1 (333) đến S2.
        Truyền PROJ' từ S3 (500) đến S2.
        Thực hiện (PAY' ⋈ EMP' ⋈ ASG' ⋈ PROJ') tại S2.

Kết quả

Chương trình phân tán:

    Giảm PROJ, thực hiện semijoin: ASG ⋉ PROJ', EMP ⋉ ASG', PAY ⋉ EMP'.
    Thực hiện nối tại S2, với tổng chi phí truyền 2666 và tổng thời gian 2711.
4.10
(a) Tập C:

    C1: R ⋈ S trên B, S ⋈ T trên D.
    C2: σ_p áp dụng trên các bộ của R hoặc kết quả chứa R.
    C3: Sử dụng index trên S.B và T.D.
    C4: Eddy được phép thay đổi thứ tự toán tử tại thời điểm chạy.
(b) Đồ thị G:
R —— S —— T
   B     D
(c) Eddy-based QEP:

    Eddy định tuyến: R ⋈ S → σ_p → S ⋈ T.
    Sử dụng index trên S.B và T.D, linh hoạt điều chỉnh thứ tự dựa trên chi phí thực tế.

(d) QEP với State Modules:

    Sử dụng SM1 (σ_p), SM2 (R ⋈ S), SM3 (S ⋈ T).
    Lợi ích: Tránh lặp lại, tái sử dụng kết quả, tăng tính thích nghi, hỗ trợ song song, giảm chi phí cho σ_p.
4.11
Cấu trúc dữ liệu đề xuất:

    Priority Queue (Min-Heap): Lưu trữ (Tuple ID, Priority Score, Timestamp) để chọn nhanh bộ ưu tiên cao nhất.
    Hash Table: Lưu trữ thông tin chi tiết {Tuple ID: {Tuple Data, State Bitmap, NOP, Timestamp}}.
    Ưu tiên: Priority Score dựa trên số lượng toán tử đã xử lý (NOP), đảm bảo "produce first results earlier".
5.1
H1 và H4 là conflict equivalent.
H3 và H4 là conflict equivalent.
Các cặp khác (H1 vs H2, H1 vs H3, H2 vs H3, H2 vs H4) không conflict equivalent.
5.2
H1: Serializable (thứ tự tuần tự: T2 → T1 → T3).
H2: Không serializable (có chu trình T1 → T2 → T1).
H3: Serializable (thứ tự tuần tự: T2 → T1 → T3).
H4: Serializable (thứ tự tuần tự: T2 → T1 → T3).
5.3
H = {L1(x), R1(x), U1(x), L1(y), W1(y), C1, L2(x), R2(x), L2(y), W2(y), C2}
Basic 2PL: Chấp nhận, vì tuân thủ quy tắc hai pha.
Strict 2PL: Không chấp nhận, vì T1 thả khóa x (U1(x)) trước khi commit (C1).
5.4
H1: Không recoverable (T3 đọc từ T2, nhưng C3 ≺H C2).
H2: Không recoverable (T1 đọc từ T2, nhưng C2 ≺H C1).
H3: Không recoverable (T3 đọc từ T2, nhưng C2 ≺H C3).
H4: Recoverable (không vi phạm).
5.5
TM:
Procedure TransactionManager(Transaction T)
    Input: Transaction T with operations (e.g., R(x), W(x), Commit, Abort)
    Output: Execution result of T

    1. Initialize:
       - T.status = "ACTIVE"
       - T.operations = list of operations in T
       - T.lockRequests = empty queue
       - T.coordinatorSite = currentSite
       - T.participantSites = set of sites involved (based on data items)

    2. For each operation op in T.operations:
       - If op is R(x) or W(x):
         - Determine site(s) s containing x
         - For each site s in participantSites:
           - Send LockRequest(T, op, x, s) to LM at site s
           - Add request to T.lockRequests
           - Wait for LockGranted or LockDenied from LM(s)
           - If LockDenied:
             - Wait (block T until lock is available)
             - Retry LockRequest
           - If LockGranted:
             - Execute op (R(x) or W(x)) locally if x is at current site
             - Send op to site s if x is remote

    3. Prepare for Commit/Abort:
       - If all operations completed successfully:
         - Send PrepareToCommit(T) to all participantSites
         - Wait for Vote(Yes/No) from each TM(s)
         - If all Vote = Yes:
           - Send GlobalCommit(T) to all participantSites
           - Set T.status = "COMMITTED"
           - Release all locks (via UnlockRequest to LM)
         - Else:
           - Send GlobalAbort(T) to all participantSites
           - Set T.status = "ABORTED"
           - Release all locks
       - Else:
         - Send GlobalAbort(T) to all participantSites
         - Set T.status = "ABORTED"
         - Release all locks

    4. Return T.status
End Procedure
LM:
Procedure LockManager(site s)
    Input: Requests from TM (LockRequest, UnlockRequest)
    Output: LockGranted, LockDenied

    1. Initialize:
       - LockTable = empty table {dataItem: {lockType, transactionList}}
       - lockType = {READ, WRITE}

    2. Handle LockRequest(T, op, x, s):
       - If op is R(x):
         - If LockTable[x] is empty or lockType = READ:
           - Add T to LockTable[x].transactionList
           - Set LockTable[x].lockType = READ
           - Send LockGranted(T, x) to TM
         - Else if LockTable[x].lockType = WRITE and T not in transactionList:
           - Send LockDenied(T, x) to TM
           - Block T until lock is released
         - Else (WRITE lock by T):
           - Send LockGranted(T, x) to TM
       - If op is W(x):
         - If LockTable[x] is empty:
           - Add T to LockTable[x].transactionList
           - Set LockTable[x].lockType = WRITE
           - Send LockGranted(T, x) to TM
         - Else if LockTable[x].lockType = READ and T not in transactionList:
           - Send LockDenied(T, x) to TM
           - Block T until all READ locks are released
         - Else if LockTable[x].lockType = WRITE and T not in transactionList:
           - Send LockDenied(T, x) to TM
           - Block T until lock is released
         - Else (WRITE lock by T):
           - Send LockGranted(T, x) to TM

    3. Handle UnlockRequest(T, x):
       - If T in LockTable[x].transactionList:
         - Remove T from LockTable[x].transactionList
         - If LockTable[x].transactionList is empty:
           - Remove x from LockTable
           - Send LockReleased(x) to TM
         - Else if LockTable[x].lockType = READ:
           - Check for pending WRITE requests
           - If exists, grant to highest priority T
         - Else (WRITE):
           - Check for pending READ/WRITE requests
           - Grant to next T in queue
       - Notify blocked transactions if locks are available

    4. Enforce 2PL:
       - After first UnlockRequest(T, x), disallow new LockRequest(T, y)
       - Maintain Growing Phase and Shrinking Phase for T
End Procedure
5.6
Procedure Centralized2PL(Transaction T)
    1. For each operation op in T.operations:
       - If op is R(x) or W(x):
         - Send LockRequest(T, op, x) to Lock Manager
         - Wait for LockGranted
         - Execute op
       - If op is Commit:
         - Send UnlockRequest(T, all locks) to Lock Manager
         - Set T.status = "COMMITTED"
       - If op is Abort:
         - Send UnlockRequest(T, all locks) to Lock Manager
         - Set T.status = "ABORTED"
    End Procedure

Procedure LockManager
    1. Maintain LockTable {dataItem: {lockType, transaction}}
    2. Handle LockRequest(T, op, x):
       - If LockTable[x] is free:
         - Grant lock (READ or WRITE)
         - Add T to LockTable[x]
       - Else if conflict (e.g., WRITE requested and READ/WRITE exists):
         - Deny lock, block T
       - After first Unlock, disallow new LockRequest
    End Procedure

Procedure ModifiedCentralized2PL(Transaction T)
    1. Initialize:
       - T.predicateLocks = empty set  // Lưu các điều kiện khóa
       - T.dataLocks = empty set      // Lưu các khóa hàng cụ thể

    2. For each operation op in T.operations:
       - If op is R(query) or W(query):  // query là điều kiện (e.g., "special meal")
         - Extract predicate P from query (e.g., "meal = special")
         - Send LockRequest(T, P, "PREDICATE") to Lock Manager  // Khóa điều kiện
         - Wait for PredicateLockGranted
         - Add P to T.predicateLocks
         - For each data item x satisfying P (e.g., rows in FC):
           - Send LockRequest(T, op, x) to Lock Manager
           - Wait for LockGranted
           - Add x to T.dataLocks
           - Execute op on x
       - If op is Commit:
         - Send UnlockRequest(T, all P in predicateLocks, "PREDICATE") to Lock Manager
         - Send UnlockRequest(T, all x in dataLocks) to Lock Manager
         - Set T.status = "COMMITTED"
       - If op is Abort:
         - Send UnlockRequest(T, all P in predicateLocks, "PREDICATE") to Lock Manager
         - Send UnlockRequest(T, all x in dataLocks) to Lock Manager
         - Set T.status = "ABORTED"
    End Procedure

Procedure ModifiedLockManager
    1. Initialize:
       - LockTable = {dataItem: {lockType, transaction}}
       - PredicateLockTable = {predicate: {lockType, transaction}}

    2. Handle LockRequest(T, op, x):
       - If op type is DATA (R(x) or W(x)):
         - If LockTable[x] is free:
           - Grant lock (READ or WRITE)
           - Add T to LockTable[x]
         - Else if conflict:
           - Deny lock, block T
       - After first Unlock, disallow new LockRequest

    3. Handle LockRequest(T, P, "PREDICATE"):
       - If PredicateLockTable[P] is empty:
         - Grant PREDICATE lock (WRITE-like, exclusive)
         - Add T to PredicateLockTable[P]
         - Send PredicateLockGranted(T, P)
       - Else if PredicateLockTable[P] contains T:
         - Send PredicateLockGranted(T, P)
       - Else:
         - Deny lock, block T
       - Ensure no new tuple satisfying P can be inserted until unlock

    4. Handle UnlockRequest(T, P, "PREDICATE"):
       - If T in PredicateLockTable[P]:
         - Remove T from PredicateLockTable[P]
         - If PredicateLockTable[P] is empty:
           - Remove P from PredicateLockTable
         - Notify blocked transactions if lock is released

    5. Enforce 2PL:
       - After first Unlock (data or predicate), disallow new LockRequest
End Procedure

5.7
Tính toán

    Thời gian đồng bộ: 24 giờ = 86,400 giây.
    Độ phân giải đồng hồ: 0.1 giây (mỗi tick).
    Drift tối đa cho phép: Vì timestamp ordering yêu cầu thứ tự thời gian phải chính xác trong phạm vi độ phân giải, sự chênh lệch tối đa giữa hai đồng hồ tại bất kỳ thời điểm nào không được vượt quá 0.1 giây. Điều này có nghĩa là drift tích lũy của mỗi đồng hồ cục bộ so với đồng hồ chuẩn trong 24 giờ phải được giới hạn để đảm bảo rằng ngay cả khi một đồng hồ chạy nhanh nhất và đồng hồ khác chạy chậm nhất, sự chênh lệch vẫn nằm trong 0.1 giây.
    Tình huống tồi tệ nhất (worst case):
        Giả sử site A có đồng hồ chạy nhanh nhất (drift dương), và site B có đồng hồ chạy chậm nhất (drift âm).
        Drift tối đa cho phép giữa hai site là 0.1 giây. Vì mỗi site có thể trôi độc lập, tổng drift giữa hai site có thể là tổng của drift của cả hai.
        Do đó, drift tối đa của một site so với đồng hồ chuẩn phải bằng một nửa khoảng chênh lệch tối đa, để tổng drift giữa hai site không vượt quá 0.1 giây.
        Tính toán: Drift tối đa của một site = 0.1 / 2 = 0.05 giây.
    Xác nhận:
        Nếu site A drift +0.05 giây và site B drift -0.05 giây trong 24 giờ, sự chênh lệch giữa A và B là 0.05 + 0.05 = 0.1 giây, vẫn nằm trong độ phân giải.
        Nếu drift của một site vượt quá 0.05 giây (ví dụ: +0.06 giây), và site khác drift -0.06 giây, sự chênh lệch sẽ là 0.06 + 0.06 = 0.12 giây, vượt quá 0.1 giây, dẫn đến khả năng timestamp ordering thất bại.

Kết quả

Mức trôi tối đa (maximum drift) tính bằng giây trong 24 giờ tại bất kỳ site nào để đảm bảo cơ chế timestamp-based đồng bộ hóa thành công là 0.05 giây.
5.8
TM:
Procedure TransactionManager(Transaction T)
    Input: Transaction T with operations (e.g., R(x), W(x), Commit, Abort)
    Output: Execution result of T

    1. Initialize:
       - T.status = "ACTIVE"
       - T.operations = list of operations in T
       - T.lockRequests = empty queue
       - T.coordinatorSite = currentSite
       - T.participantSites = set of sites involved
       - T.waitFor = empty set  // Giao dịch mà T đang chờ
       - T.deadlockDetected = false

    2. For each operation op in T.operations:
       - If op is R(x) or W(x):
         - Determine site(s) s containing x
         - For each site s in participantSites:
           - Send LockRequest(T, op, x, s) to LM at site s
           - Add request to T.lockRequests
           - Wait for LockGranted or LockDenied from LM(s)
           - If LockDenied:
             - Add waiting transaction (from LM) to T.waitFor
             - Send WaitInfo(T, waitFor) to DeadlockDetector
             - Wait (block T until lock is available or deadlock resolved)
             - If DeadlockNotification(T) received:
               - Set T.deadlockDetected = true
               - Abort T (send GlobalAbort(T))
               - Exit loop
           - If LockGranted:
             - Execute op locally if x is at current site
             - Send op to site s if x is remote

    3. Prepare for Commit/Abort:
       - If T.deadlockDetected = false and all operations completed:
         - Send PrepareToCommit(T) to all participantSites
         - Wait for Vote(Yes/No) from each TM(s)
         - If all Vote = Yes:
           - Send GlobalCommit(T) to all participantSites
           - Set T.status = "COMMITTED"
           - Release all locks (via UnlockRequest to LM)
         - Else:
           - Send GlobalAbort(T) to all participantSites
           - Set T.status = "ABORTED"
           - Release all locks
       - Else:
         - Send GlobalAbort(T) to all participantSites
         - Set T.status = "ABORTED"
         - Release all locks

    4. Return T.status
End Procedure

LM:
Procedure LockManager(site s)
    Input: Requests from TM (LockRequest, UnlockRequest)
    Output: LockGranted, LockDenied, WaitInfo

    1. Initialize:
       - LockTable = {dataItem: {lockType, transactionList}}
       - lockType = {READ, WRITE}
       - WaitForGraph = {transaction: {waitingFor}}  // Phần WFG cục bộ

    2. Handle LockRequest(T, op, x, s):
       - If op is R(x):
         - If LockTable[x] is empty or lockType = READ:
           - Add T to LockTable[x].transactionList
           - Set LockTable[x].lockType = READ
           - Send LockGranted(T, x) to TM
         - Else if LockTable[x].lockType = WRITE and T not in transactionList:
           - Identify blocking transaction Tj in LockTable[x]
           - Add T -> Tj to WaitForGraph[T].waitingFor
           - Send LockDenied(T, x) and WaitInfo(T, Tj) to TM
           - Block T
         - Else:
           - Send LockGranted(T, x) to TM
       - If op is W(x):
         - If LockTable[x] is empty:
           - Add T to LockTable[x].transactionList
           - Set LockTable[x].lockType = WRITE
           - Send LockGranted(T, x) to TM
         - Else if LockTable[x].lockType = READ or WRITE and T not in transactionList:
           - Identify blocking transaction Tj in LockTable[x]
           - Add T -> Tj to WaitForGraph[T].waitingFor
           - Send LockDenied(T, x) and WaitInfo(T, Tj) to TM
           - Block T
         - Else:
           - Send LockGranted(T, x) to TM

    3. Handle UnlockRequest(T, x):
       - If T in LockTable[x].transactionList:
         - Remove T from LockTable[x].transactionList
         - If LockTable[x].transactionList is empty:
           - Remove x from LockTable
           - Send LockReleased(x) to TM
         - Else:
           - Check WaitForGraph for blocked transactions
           - If T -> Tj exists and Tj no longer blocks:
             - Remove T -> Tj from WaitForGraph
             - Notify TM to retry LockRequest for blocked T
       - Send updated WaitForGraph to DeadlockDetector

    4. Enforce 2PL:
       - After first UnlockRequest(T, x), disallow new LockRequest(T, y)

    5. Handle DeadlockDetectorInput:
       - Periodically send WaitForGraph to coordinator
       - If DeadlockNotification received for T:
         - Send DeadlockNotification(T) to TM
End Procedure

Procedure DeadlockDetector
    1. Initialize:
       - GlobalWaitForGraph = empty

    2. Collect WFG:
       - Receive WaitInfo from all TMs
       - Merge local WaitForGraphs into GlobalWaitForGraph

    3. Detect Deadlock:
       - Use depth-first search or cycle detection on GlobalWaitForGraph
       - If cycle detected (e.g., T1 -> T2 -> T1):
         - Select victim (e.g., T with lowest rollback cost)
         - Send DeadlockNotification(victim) to TM of victim

    4. Repeat periodically or on significant changes
End Procedure

5.9

Mối quan hệ với kích thước giao dịch (Transaction Size)
Kích thước giao dịch được định nghĩa là số lượng thao tác (operations) mỗi giao dịch, bao gồm các thao tác đọc và ghi. Mối quan hệ giữa yêu cầu lưu trữ của TM và kích thước giao dịch có thể được phân tích như sau:

Tăng trưởng tuyến tính với số thao tác:

Read Set và Write Set: Số lượng mục dữ liệu trong Read Set (các mục đã đọc) và Write Set (các mục sẽ ghi) tăng trực tiếp theo số lượng thao tác. Nếu mỗi thao tác tương ứng với một mục dữ liệu, thì kích thước của các tập hợp này tỷ lệ với số thao tác.

Ví dụ: Nếu một giao dịch có 10 thao tác đọc và 5 thao tác ghi, Read Set chứa tối đa 10 mục và Write Set chứa 5 mục (có thể trùng lặp nếu cùng mục dữ liệu).


Danh sách thao tác: TM cần lưu trữ lịch sử thao tác để kiểm tra trong pha xác thực. Số lượng thao tác lưu trữ tỷ lệ trực tiếp với kích thước giao dịch.


Chi phí cố định bổ sung:

Dù kích thước giao dịch thay đổi, TM vẫn cần lưu trữ một số thông tin cố định như timestamp, trạng thái giao dịch, và tham chiếu đến các giao dịch khác. Điều này tạo ra một chi phí cơ bản không phụ thuộc vào số thao tác.
Tuy nhiên, trong pha xác thực, TM phải so sánh với các giao dịch khác, và số lượng so sánh phụ thuộc vào số giao dịch đang hoạt động (không phải kích thước giao dịch), nhưng dữ liệu so sánh (Read/Write Sets) lại phụ thuộc vào số thao tác.


Tác động trong Validation Phase:

Trong pha xác thực, TM kiểm tra xem có giao dịch nào commit trong khoảng thời gian từ khi giao dịch bắt đầu đọc đến khi xác thực, và các giao dịch đó có xung đột với Read Set hoặc Write Set của giao dịch hiện tại không.
Số lượng xung đột tiềm năng tăng khi Read Set và Write Set lớn hơn (do nhiều thao tác), dẫn đến yêu cầu lưu trữ tạm thời cao hơn để giữ thông tin so sánh.
Nếu xung đột xảy ra, TM cần lưu trữ thông tin rollback (ví dụ: giá trị cũ của dữ liệu), và số lượng này cũng tỷ lệ với số thao tác ghi.


Tổng yêu cầu lưu trữ:

Yêu cầu lưu trữ của TM có thể được biểu diễn như:
$$Storage_{TM} = S_{fixed} + S_{ops} \cdot N_{ops}$$

$ S_{fixed} $: Chi phí cố định (timestamp, trạng thái, v.v.).
$ S_{ops} $: Chi phí lưu trữ mỗi thao tác (bao gồm Read/Write Sets).
$ N_{ops} $: Số lượng thao tác (kích thước giao dịch).


Mối quan hệ là tuyến tính, với độ dốc phụ thuộc vào độ phức tạp của mỗi thao tác (số lượng dữ liệu liên quan).

5.10

Procedure TransactionManager(Transaction T)
    Input: Transaction T with operations (e.g., R(x), W(x), Commit, Abort)
    Output: Execution result of T

    1. Initialize:
       - T.status = "ACTIVE"
       - T.startTS = currentTimestamp()  // Gán timestamp khi bắt đầu
       - T.readSet = empty set  // Tập các mục dữ liệu đã đọc
       - T.writeSet = empty set  // Tập các mục dữ liệu sẽ ghi
       - T.operations = list of operations in T
       - T.participantSites = set of sites involved (based on data items)
       - T.coordinatorSite = currentSite

    2. Read Phase:
       - For each operation op in T.operations:
         - If op is R(x):
           - Determine site s containing x
           - Send ReadRequest(T, x) to Scheduler at site s
           - Receive value of x
           - Add x to T.readSet
           - Store value locally for computation
         - If op is W(x):
           - Add x to T.writeSet
           - Compute and store new value of x locally (in private workspace)

    3. Validation Phase:
       - T.validationTS = currentTimestamp()  // Timestamp tại thời điểm xác thực
       - For each site s in participantSites:
         - Send ValidationRequest(T, T.startTS, T.validationTS, T.readSet, T.writeSet) to Scheduler at site s
         - Wait for ValidationResult(Yes/No) from Scheduler(s)
       - If all ValidationResult = Yes:
         - Proceed to Write Phase
       - Else:
         - Set T.status = "ABORTED"
         - Send GlobalAbort(T) to all participantSites
         - Return T.status

    4. Write Phase:
       - For each site s in participantSites:
         - Send WriteRequest(T, T.writeSet) to Scheduler at site s
         - Wait for WriteAck from Scheduler(s)
       - If all WriteAck received:
         - Send GlobalCommit(T) to all participantSites
         - Set T.status = "COMMITTED"
       - Else:
         - Send GlobalAbort(T) to all participantSites
         - Set T.status = "ABORTED"

    5. Return T.status
End Procedure

Procedure Scheduler(site s)
    Input: Requests from TM (ReadRequest, ValidationRequest, WriteRequest)
    Output: Responses to TM

    1. Initialize:
       - DataStore = {dataItem: value}  // Dữ liệu tại site
       - CommitLog = {transaction: {commitTS, readSet, writeSet}}  // Lịch sử giao dịch đã commit
       - ActiveTransactions = empty set  // Giao dịch đang hoạt động

    2. Handle ReadRequest(T, x):
       - If x in DataStore:
         - Send value of x to TM
       - Else:
         - Send ReadError to TM
       - Add T to ActiveTransactions

    3. Handle ValidationRequest(T, startTS, validationTS, readSet, writeSet):
       - For each transaction Tj in CommitLog where Tj.commitTS > startTS and Tj.commitTS < validationTS:
         - If Tj.writeSet intersects T.readSet:
           - Send ValidationResult(No) to TM  // Xung đột: Tj ghi vào mục T đã đọc
           - Return
         - If Tj.writeSet intersects T.writeSet:
           - Send ValidationResult(No) to TM  // Xung đột: Tj ghi vào mục T sẽ ghi
           - Return
       - Send ValidationResult(Yes) to TM

    4. Handle WriteRequest(T, writeSet):
       - For each (x, value) in writeSet:
         - Update DataStore[x] = value
       - Add T to CommitLog with {commitTS: validationTS, readSet, writeSet}
       - Send WriteAck to TM

    5. Cleanup:
       - Periodically remove old entries from CommitLog (e.g., entries with commitTS older than any active transaction's startTS)
       - Remove T from ActiveTransactions after commit/abort
End Procedure

5.12

Lý do Serializability bị coi là hạn chế

    Serializability chỉ dựa trên thứ tự xung đột (conflict order) giữa các thao tác đọc/ghi, mà không xem xét ngữ nghĩa ứng dụng hoặc các ràng buộc cụ thể.
    Trong hệ thống phân tán, các lịch sử có thể duy trì tính nhất quán thông qua cơ chế khác (ví dụ: giao dịch bù trừ hoặc kiểm tra ứng dụng), nhưng bị từ chối bởi tiêu chí serializability do không có thứ tự tuần tự tương đương.

Ví dụ 1: Giao dịch chuyển tiền với bù trừ (Compensating Transaction)

Giả sử có hai site, Site 1 và Site 2, mỗi site quản lý một tài khoản ngân hàng (A tại Site 1, B tại Site 2). Tổng số tiền trong A và B phải luôn bằng 1000 đơn vị (ràng buộc ứng dụng). Hai giao dịch sau được thực thi đồng thời:

    T1: Chuyển 200 từ A đến B.
    T2: Chuyển 300 từ B đến A.

Lịch sử phân tán (H):

    Site 1: W1(A, 800), C1 (T1 ghi A = 800, commit).
    Site 2: W2(B, 500), C2 (T2 ghi B = 500, commit).
    Thực tế, hai giao dịch được thực thi song song, với các bước trung gian:
        Ban đầu: A = 1000, B = 0.
        T1 giảm A xuống 800, T2 tăng B lên 500 (tổng tạm thời = 1300).
        T2 giảm B xuống 200, T1 tăng A lên 1000 (tổng tạm thời = 1200).
        Sau commit: A = 800, B = 200 (tổng = 1000).

Phân tích:

    Tính nhất quán: Ràng buộc ứng dụng (tổng A + B = 1000) được duy trì, vì các thay đổi bù trừ nhau. Không có dữ liệu "dirty" vì tất cả commit đều hợp lệ.
    Serializability:
        Đồ thị ưu tiên (precedence graph): Không có cặp thao tác xung đột trực tiếp (vì W1(A) và W2(B) tác động lên các đối tượng khác nhau).
        Tuy nhiên, nếu xem xét các bước trung gian, thứ tự thực tế không tương đương với bất kỳ thứ tự tuần tự nào (ví dụ: T1 → T2 hoặc T2 → T1 sẽ không tạo ra cùng kết quả trung gian).
        Kết luận: H không serializable, vì không có lịch sử tuần tự tương đương về xung đột (do thiếu thông tin trung gian trong lịch sử cuối cùng).

5.13
Termination Protocol trong 2PC với Distributed Communication Topology

Giao thức chấm dứt cần giải quyết hai trường hợp chính: (1) Coordinator thất bại và (2) Participant thất bại.
1. Coordinator Failure

    Vấn đề: Nếu coordinator thất bại trong khi thực thi 2PC, các participant không nhận được thông điệp Commit hoặc Abort, dẫn đến trạng thái chặn.
    Termination Protocol:
        Election of New Coordinator:
            Các site còn lại phát hiện coordinator thất bại (thông qua timeout hoặc giao thức phát hiện sự cố).
            Sử dụng một giao thức bầu chọn (election protocol) để chọn coordinator mới. Ví dụ, trong cấu trúc cây:
                Nếu coordinator là root, các site con (children) bắt đầu bầu chọn một site mới làm root (dựa trên ID cao nhất, ưu tiên, hoặc độ trễ thấp nhất).
                Trong cấu trúc vòng, site kế tiếp trong vòng đảm nhận vai trò coordinator.
        State Collection:
            Coordinator mới gửi yêu cầu trạng thái (StateRequest) đến tất cả participant còn lại.
            Mỗi participant trả lời trạng thái của mình:
                Prepared (đã gửi Yes trong Prepare Phase).
                Aborted (đã gửi No hoặc đã nhận Abort).
                Unknown (chưa nhận được Prepare).
        Decision Making:
            Nếu tất cả participant trả lời Prepared, coordinator mới gửi Commit.
            Nếu có bất kỳ Aborted hoặc Unknown, coordinator gửi Abort.
        Propagation:
            Coordinator mới gửi quyết định (Commit hoặc Abort) đến tất cả participant thông qua cấu trúc liên lạc (ví dụ: lan truyền qua cây hoặc vòng).
    Thảo luận:
        Timeout: Các participant sử dụng timeout để phát hiện coordinator thất bại, nhưng timeout phải đủ dài để tránh quyết định sai (false positives).
        Consistency: Giao thức bầu chọn phải đảm bảo chỉ có một coordinator mới được chọn, tránh trường hợp nhiều coordinator đưa ra quyết định mâu thuẫn.

2. Participant Failure

    Vấn đề: Nếu một participant thất bại:
        Trong Prepare Phase: Coordinator không nhận được phản hồi từ participant, dẫn đến nguy cơ chặn.
        Trong Commit Phase: Participant không nhận được quyết định Commit/Abort.
    Termination Protocol:
        Coordinator Handling Participant Failure:
            Prepare Phase:
                Coordinator sử dụng timeout để phát hiện participant thất bại.
                Nếu không nhận được phản hồi từ participant sau timeout, coordinator coi đó là No và gửi Abort toàn cục.
            Commit Phase:
                Nếu participant thất bại sau khi gửi Yes nhưng trước khi nhận Commit, các site khác vẫn có thể tiếp tục (participant thất bại sẽ phục hồi sau).
        Participant Handling Coordinator Failure:
            Nếu participant không nhận được quyết định sau timeout, nó phối hợp với các site khác:
                Gửi yêu cầu trạng thái (StateRequest) đến các site láng giềng (theo cấu trúc liên lạc).
                Nếu bất kỳ site nào đã nhận Commit hoặc Abort, participant áp dụng quyết định đó.
                Nếu không site nào biết trạng thái, bầu chọn coordinator mới (như trên).
        Distributed Decision:
            Trong cấu trúc cây, các site con của participant thất bại gửi yêu cầu trạng thái lên site cha.
            Nếu site cha biết trạng thái (đã nhận Commit/Abort), lan truyền xuống.
            Nếu không, site cha tiếp tục hỏi lên đến root hoặc coordinator mới.

Đặc điểm của Termination Protocol

    Non-Blocking (giảm chặn): Giao thức chấm dứt giúp các site còn lại đưa ra quyết định mà không cần chờ site thất bại phục hồi, giảm trạng thái chặn.
    Consistency: Đảm bảo tất cả site còn lại đồng ý trên một quyết định (commit hoặc abort), duy trì tính nhất quán.
    Overhead: Bầu chọn coordinator mới và lan truyền trạng thái gây thêm chi phí liên lạc, đặc biệt trong cấu trúc phức tạp như mesh.
Kết luận

Giao thức chấm dứt trong 2PC với cấu trúc liên lạc phân tán dựa vào bầu chọn coordinator mới và phối hợp trạng thái giữa các site để xử lý sự cố. Điều này đảm bảo tính nhất quán và giảm chặn, nhưng tăng chi phí liên lạc.

5.14

Thiết kế giao thức 3PC với Linear Communication Topology
Tham số

    Coordinator: Site đầu tiên trong chuỗi (ví dụ: S1).
    Participants: Các site còn lại (S2, S3, ..., Sn).
    Trạng thái: Mỗi site có thể ở trạng thái INIT, PREPARED, PRE-COMMITTED, COMMITTED, hoặc ABORTED.

Procedure ThreePhaseCommit(site S)
    Input: Transaction T, site ID, predecessor, successor
    Output: Final state of T (COMMITTED or ABORTED)

    1. Initialize:
       - S.state = "INIT"
       - S.vote = "UNDECIDED"
       - S.predecessor = previous site in chain (null for coordinator)
       - S.successor = next site in chain (null for last site)

    2. Prepare Phase:
       - If S is Coordinator (e.g., S1):
         - Send Prepare(T) to S.successor
         - Wait for PrepareAck or Abort from all participants
       - Else (Participant):
         - Receive Prepare(T) from S.predecessor
         - If local data can be committed:
           - Set S.vote = "Yes"
           - Send PrepareAck(T) to S.successor
         - Else:
           - Set S.vote = "No"
           - Send Abort(T) to S.predecessor
           - Set S.state = "ABORTED"
           - Return "ABORTED"

    3. Pre-Commit Phase:
       - If S is Coordinator:
         - If all PrepareAck received:
           - Set S.state = "PRE-COMMITTED"
           - Send PreCommit(T) to S.successor
         - Else if Abort received:
           - Send GlobalAbort(T) to S.successor
           - Set S.state = "ABORTED"
           - Return "ABORTED"
       - Else (Participant):
         - Receive PreCommit(T) from S.predecessor
         - Set S.state = "PRE-COMMITTED"
         - Send PreCommitAck(T) to S.successor
         - If S.successor is null (last site):
           - Send PreCommitAck(T) back to S.predecessor

    4. Commit Phase:
       - If S is Coordinator:
         - Receive PreCommitAck from last site (propagated back)
         - Send GlobalCommit(T) to S.successor
         - Set S.state = "COMMITTED"
       - Else (Participant):
         - Receive GlobalCommit(T) from S.predecessor
         - Perform local commit
         - Set S.state = "COMMITTED"
         - Send CommitAck(T) to S.successor
         - If S.successor is null:
           - Send CommitAck(T) back to S.predecessor

    5. Termination Protocol (Site Failure):
       - If S.predecessor fails (timeout):
         - If S.state = "PRE-COMMITTED":
           - Send GlobalCommit(T) to S.successor
           - Set S.state = "COMMITTED"
         - Else if S.state = "INIT" or "PREPARED":
           - Send Abort(T) to S.successor
           - Set S.state = "ABORTED"
       - If S.successor fails (timeout):
         - Wait for recovery or use alternate path (if available)
         - Propagate decision back to S.predecessor when successor recovers
End Procedure

Chi tiết các pha

    Prepare Phase:
        Coordinator (S1) gửi Prepare(T) qua chuỗi (S1 → S2 → S3 → ...).
        Mỗi participant kiểm tra khả năng commit và gửi PrepareAck hoặc Abort ngược lại.
        Nếu có Abort, chuỗi dừng và lan truyền Abort ngược về coordinator.
    Pre-Commit Phase:
        Nếu tất cả PrepareAck, coordinator gửi PreCommit(T) qua chuỗi.
        Mỗi site chuyển sang trạng thái PRE-COMMITTED và xác nhận bằng PreCommitAck, lan truyền ngược về coordinator.
        Trạng thái PRE-COMMITTED cho phép các site tự động commit nếu coordinator thất bại.
    Commit Phase:
        Sau khi nhận PreCommitAck từ cuối chuỗi, coordinator gửi GlobalCommit(T).
        Mỗi site commit cục bộ, gửi CommitAck ngược lại, và chuỗi hoàn tất.

Termination Protocol khi Site Failure

    Coordinator Failure:
        Nếu S1 thất bại sau PreCommit, các site đã ở PRE-COMMITTED sẽ tự động gửi GlobalCommit qua chuỗi, dựa trên trạng thái đồng thuận trước đó.
    Participant Failure:
        Nếu S2 thất bại trong Prepare Phase, S3 và các site sau nhận Abort từ S1.
        Nếu S2 thất bại sau PreCommit, S3 có thể tiếp tục gửi GlobalCommit nếu đã nhận PreCommit.
    Recovery:
        Site thất bại khi phục hồi sẽ hỏi trạng thái từ S.predecessor hoặc S.successor, và áp dụng quyết định đã lan truyền.
5.15
Procedure Centralized3PCTerminationProtocol(site S)
    Input: Transaction T, site role (Coordinator or Participant), list of participants
    Output: Final state of T (COMMITTED or ABORTED)

    1. Initialize:
       - S.state = current state (INIT, PREPARED, PRE-COMMITTED, COMMITTED, ABORTED)
       - S.isCoordinator = true if S is coordinator, false otherwise
       - S.participants = list of participant sites
       - S.timeout = predefined timeout value

    2. Detect Failure:
       - If S.isCoordinator:
         - If S.state = PREPARED or PRE-COMMITTED and no decision sent (e.g., due to crash):
           - Set recoveryFlag = true
           - Wait for recovery or timeout
       - Else (Participant):
         - If no message from coordinator after timeout:
           - Set recoveryFlag = true

    3. Modified Termination Phase:
       - If S.isCoordinator and recoveryFlag:
         - Send StateRequest(T) to all participants in S.participants
         - Wait for StateResponse(state) from each participant
         - Collect states into stateList
         - Determine global decision:
           - If all StateResponse = PREPARED or PRE-COMMITTED:
             - Set S.decision = "COMMITTED"
             - Send GlobalCommit(T) to all participants
           - Else if any StateResponse = ABORTED or INIT:
             - Set S.decision = "ABORTED"
             - Send GlobalAbort(T) to all participants
           - Else (mixed states or missing responses):
             - Set S.decision = "ABORTED"  // Conservative approach
             - Send GlobalAbort(T) to all participants
         - Update S.state = S.decision
       - Else (Participant and recoveryFlag):
         - Receive StateRequest(T) from coordinator
         - Send StateResponse(S.state) to coordinator
         - Wait for GlobalCommit(T) or GlobalAbort(T)
         - If GlobalCommit(T) received:
           - Set S.state = "COMMITTED"
         - Else if GlobalAbort(T) received:
           - Set S.state = "ABORTED"

    4. Handle Participant Failure:
       - If S.isCoordinator and no StateResponse from participant P after timeout:
         - Assume P.state = INIT (conservative)
         - Proceed with decision based on remaining responses
       - If S is Participant and successor fails:
         - Wait for coordinator recovery or alternate communication

    5. Return S.state
End Procedure
Chi tiết các bước

    Detect Failure:
        Coordinator hoặc participant phát hiện sự cố qua timeout hoặc không nhận được thông điệp mong đợi.
        recoveryFlag kích hoạt giao thức chấm dứt.
    Modified Termination Phase:
        Coordinator Action:
            Gửi StateRequest đến tất cả participant thay vì phát tán trạng thái của mình.
            Thu thập StateResponse từ các participant, bao gồm trạng thái hiện tại (INIT, PREPARED, PRE-COMMITTED, COMMITTED, ABORTED).
            Quyết định dựa trên trạng thái thu thập được:
                Nếu tất cả ở PREPARED hoặc PRE-COMMITTED, gửi GlobalCommit.
                Nếu có bất kỳ ABORTED hoặc INIT, gửi GlobalAbort.
                Nếu thiếu phản hồi, chọn ABORT để đảm bảo an toàn (conservative approach).
        Participant Action:
            Nhận StateRequest, gửi lại trạng thái hiện tại.
            Chờ quyết định từ coordinator và áp dụng.
    Handle Participant Failure:
        Nếu participant không phản hồi, coordinator coi đó là trạng thái INIT (chưa chuẩn bị), dẫn đến abort để tránh mâu thuẫn.
        Participant không cần hành động chủ động khi coordinator thất bại, vì coordinator sẽ thu thập trạng thái khi phục hồi.

5.18

Procedure LRM_TransactionProcessing(Transaction T)
    Input: Transaction T with operations (e.g., R(x), W(x), Commit, Abort)
    Output: Execution result of T

    1. Initialize:
       - Log = empty list  // Nhật ký lưu trữ bản ghi
       - Buffer = {dataItem: value}  // Bộ đệm lưu trữ các thay đổi tạm thời
       - StableStorage = {dataItem: value}  // Lưu trữ ổn định trên đĩa

    2. For each operation op in T.operations:
       - If op is R(x):
         - If x in Buffer:
           - Return Buffer[x]
         - Else if x in StableStorage:
           - Load x into Buffer
           - Return Buffer[x]
         - Else:
           - Return error (x not found)
       - If op is W(x, value):
         - Write log record: <T, W, x, oldValue, newValue> to Log
         - Update Buffer[x] = newValue
         - // No-Fix: Do not write to StableStorage yet
         - // No-Flush: Do not force Buffer to disk

    3. Commit/Abort Handling:
       - If T requests Commit:
         - Write log record: <T, Commit> to Log
         - Append Log to StableStorage (force log to disk)
         - // No-Flush: Do not force Buffer to StableStorage
         - Set T.status = "COMMITTED"
         - Periodically flush Buffer to StableStorage (asynchronously)
       - If T requests Abort:
         - Write log record: <T, Abort> to Log
         - Discard Buffer changes for T (revert to old values if needed)
         - Append Log to StableStorage
         - Set T.status = "ABORTED"

    4. Return T.status
End Procedure

Procedure LRM_Recovery()
    Input: Log, StableStorage, Buffer
    Output: Restored state of StableStorage

    1. Initialize:
       - Buffer = empty  // Reset buffer
       - RedoList = empty  // List of committed transactions to redo

    2. Analyze Log:
       - Read Log from StableStorage
       - For each log record in Log (from oldest to newest):
         - If record is <T, Commit>:
           - Add T to RedoList
         - If record is <T, Abort>:
           - Skip T (no action needed, since No-Fix ensures uncommitted changes are not on disk)

    3. Redo Phase:
       - For each transaction T in RedoList:
         - For each log record <T, W, x, oldValue, newValue>:
           - Load x from StableStorage into Buffer if not already loaded
           - Update Buffer[x] = newValue
       - Flush Buffer to StableStorage (force all changes to disk)

    4. Cleanup:
       - Clear Buffer
       - Log new checkpoint: <Checkpoint> to StableStorage
       - Truncate Log (remove old entries before checkpoint)

    5. Return "Recovery Complete"
End Procedure

Giải thích thuật toán
Transaction Processing

    Read Operation: Đọc từ bộ đệm nếu có, nếu không thì đọc từ đĩa. Không cần khóa vì chiến lược No-Fix/No-Flush dựa vào log để phục hồi.
    Write Operation:
        Ghi log trước (Write-Ahead Logging - WAL) để đảm bảo khả năng redo.
        Cập nhật bộ đệm, nhưng không ghi ra đĩa (No-Fix).
        Không ép bộ đệm ra đĩa ngay (No-Flush).
    Commit/Abort:
        Commit: Ghi log commit, nhưng không ép bộ đệm ra đĩa ngay. Thay đổi được ghi ra đĩa định kỳ (asynchronously).
        Abort: Hủy thay đổi trong bộ đệm, không cần undo trên đĩa (vì No-Fix).

Recovery After Crash

    Analyze Log:
        Xác định các giao dịch đã commit (cần redo).
        Bỏ qua các giao dịch chưa commit (vì No-Fix đảm bảo chúng không ảnh hưởng đến đĩa).
    Redo Phase:
        Chỉ áp dụng lại các thay đổi của giao dịch đã commit.
        Cập nhật bộ đệm và ghi ra đĩa sau khi hoàn tất redo.
    Cleanup:
        Đặt checkpoint để giảm chi phí cho lần phục hồi sau.
        Xóa log cũ để tiết kiệm không gian.
5.19
1. Transaction Manager (TM)

TM tại mỗi site quản lý vòng đời giao dịch, gửi yêu cầu khóa đến Scheduler, và phối hợp với LRM để ghi log và xử lý commit/abort.

Procedure TransactionManager(Transaction T)
    Input: Transaction T with operations (e.g., R(x), W(x), Commit, Abort)
    Output: Execution result of T

    1. Initialize:
       - T.status = "ACTIVE"
       - T.operations = list of operations in T
       - T.lockRequests = empty queue
       - T.site = current site

    2. For each operation op in T.operations:
       - If op is R(x) or W(x):
         - Send LockRequest(T, op, x) to Centralized Scheduler
         - Add request to T.lockRequests
         - Wait for LockGranted or LockDenied from Scheduler
         - If LockDenied:
             - Wait (block T until lock is available)
             - Retry LockRequest
         - If LockGranted:
             - If op is R(x):
                 - Send ReadRequest(T, x) to LRM at T.site
                 - Receive value of x from LRM
             - If op is W(x, value):
                 - Send WriteRequest(T, x, value) to LRM at T.site

    3. Commit/Abort Handling:
       - If T requests Commit:
         - Send PrepareToCommit(T) to all participant sites (if distributed)
         - Wait for Vote(Yes/No) from each site
         - If all Vote = Yes:
             - Send CommitRequest(T) to LRM
             - Send UnlockRequest(T, all locks) to Scheduler
             - Set T.status = "COMMITTED"
         - Else:
             - Send AbortRequest(T) to LRM
             - Send UnlockRequest(T, all locks) to Scheduler
             - Set T.status = "ABORTED"
       - If T requests Abort:
         - Send AbortRequest(T) to LRM
         - Send UnlockRequest(T, all locks) to Scheduler
         - Set T.status = "ABORTED"

    4. Return T.status
End Procedure
2. Scheduler (Centralized Two-Phase Locking)

Scheduler trung tâm quản lý tất cả các khóa, đảm bảo tính serializability thông qua 2PL.

Procedure Scheduler()
    Input: Requests from TM (LockRequest, UnlockRequest)
    Output: LockGranted, LockDenied

    1. Initialize:
       - LockTable = {dataItem: {lockType, transactionList}}
       - lockType = {READ, WRITE}

    2. Handle LockRequest(T, op, x):
       - If op is R(x):
         - If LockTable[x] is empty or lockType = READ:
             - Add T to LockTable[x].transactionList
             - Set LockTable[x].lockType = READ
             - Send LockGranted(T, x) to TM
         - Else if LockTable[x].lockType = WRITE and T not in transactionList:
             - Send LockDenied(T, x) to TM
             - Block T until lock is available
         - Else (WRITE lock by T):
             - Send LockGranted(T, x) to TM
       - If op is W(x):
         - If LockTable[x] is empty:
             - Add T to LockTable[x].transactionList
             - Set LockTable[x].lockType = WRITE
             - Send LockGranted(T, x) to TM
         - Else if LockTable[x].lockType = READ or WRITE and T not in transactionList:
             - Send LockDenied(T, x) to TM
             - Block T until lock is available
         - Else (WRITE lock by T):
             - Send LockGranted(T, x) to TM

    3. Handle UnlockRequest(T, x):
       - If T in LockTable[x].transactionList:
           - Remove T from LockTable[x].transactionList
           - If LockTable[x].transactionList is empty:
               - Remove x from LockTable
               - Send LockReleased(x) to TM
           - Else if LockTable[x].lockType = READ:
               - Check for pending WRITE requests
               - Grant to highest priority T
           - Else (WRITE):
               - Grant to next T in queue
       - Notify blocked transactions if locks are available

    4. Enforce 2PL:
       - After first UnlockRequest(T, x), disallow new LockRequest(T, y)
End Procedure
3. Local Recovery Manager (LRM) - No-Fix/No-Flush

LRM quản lý việc đọc/ghi dữ liệu tại site cục bộ và phục hồi sau sự cố, sử dụng chiến lược No-Fix/No-Flush.

Procedure LRM_TransactionProcessing(Transaction T)
    Input: Transaction T with requests (ReadRequest, WriteRequest, CommitRequest, AbortRequest)
    Output: Execution result of T

    1. Initialize:
       - Log = empty list
       - Buffer = {dataItem: value}
       - StableStorage = {dataItem: value}

    2. Handle ReadRequest(T, x):
       - If x in Buffer:
           - Return Buffer[x]
       - Else if x in StableStorage:
           - Load x into Buffer
           - Return Buffer[x]
       - Else:
           - Return error (x not found)

    3. Handle WriteRequest(T, x, value):
       - Write log record: <T, W, x, oldValue, newValue> to Log
       - Update Buffer[x] = newValue
       - // No-Fix: Do not write to StableStorage yet
       - // No-Flush: Do not force Buffer to disk

    4. Handle CommitRequest(T):
       - Write log record: <T, Commit> to Log
       - Append Log to StableStorage (force log to disk)
       - // No-Flush: Do not force Buffer to StableStorage
       - Periodically flush Buffer to StableStorage (asynchronously)
       - Return "COMMITTED"

    5. Handle AbortRequest(T):
       - Write log record: <T, Abort> to Log
       - Discard Buffer changes for T (revert to old values if needed)
       - Append Log to StableStorage
       - Return "ABORTED"
End Procedure

Procedure LRM_Recovery()
    Input: Log, StableStorage, Buffer
    Output: Restored state of StableStorage

    1. Initialize:
       - Buffer = empty
       - RedoList = empty

    2. Analyze Log:
       - Read Log from StableStorage
       - For each log record in Log (from oldest to newest):
           - If record is <T, Commit>:
               - Add T to RedoList
           - If record is <T, Abort>:
               - Skip T (no action needed)

    3. Redo Phase:
       - For each transaction T in RedoList:
           - For each log record <T, W, x, oldValue, newValue>:
               - Load x from StableStorage into Buffer if not already loaded
               - Update Buffer[x] = newValue
       - Flush Buffer to StableStorage

    4. Cleanup:
       - Clear Buffer
       - Log new checkpoint: <Checkpoint> to StableStorage
       - Truncate Log (remove old entries before checkpoint)

    5. Return "Recovery Complete"
End Procedure

Giải thích thuật toán
Transaction Manager (TM)

    Lock Management: Gửi yêu cầu khóa đến Scheduler trung tâm, chờ LockGranted trước khi thực hiện thao tác.
    Operation Execution: Gửi yêu cầu đọc/ghi đến LRM sau khi có khóa.
    Commit/Abort: Phối hợp với các site (nếu phân tán) qua 2PC, gửi yêu cầu commit/abort đến LRM, và thả khóa qua Scheduler.
    TM đảm bảo tuân thủ 2PL bằng cách xin khóa trước và thả khóa sau commit/abort.

Scheduler (Centralized 2PL)

    Lock Handling:
        READ lock: Cho phép nhiều giao dịch đọc cùng lúc, nhưng chặn WRITE.
        WRITE lock: Chỉ cho một giao dịch, chặn cả READ và WRITE từ giao dịch khác.
    2PL Enforcement: Sau khi thả khóa đầu tiên, không cho phép xin khóa mới (Shrinking Phase).
    Scheduler trung tâm đảm bảo tính serializability toàn cục, ngay cả trong hệ thống phân tán.

Local Recovery Manager (LRM) - No-Fix/No-Flush

    Transaction Processing:
        Đọc từ bộ đệm hoặc đĩa.
        Ghi: Cập nhật bộ đệm, ghi log, nhưng không ghi ra đĩa ngay (No-Fix/No-Flush).
        Commit: Ghi log commit, không ép bộ đệm ra đĩa ngay.
        Abort: Hủy thay đổi trong bộ đệm, không cần undo trên đĩa.
    Recovery:
        Chỉ redo các giao dịch đã commit (dựa trên log).
        Không cần undo, vì No-Fix đảm bảo các thay đổi chưa commit không ảnh hưởng đến đĩa.
        Ghi lại bộ đệm ra đĩa sau redo.
